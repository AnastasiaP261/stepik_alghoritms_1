# Задачи с курса Stepik "Алгоритмы: Теория и практика. Методы"
[Cсылка на курс](https://stepik.org/course/217/info)

В этом репозитории будут собраны мои решения (на Python) наиболее интересных для меня задач с данного курса. Возможно, для некоторых задач будет приведен ход моих мыслей при решении или будет текстовое пояснение кода, а может и нет. Постаралась привести задачи в том порядке, в котором они даны в курсе.

###  Статусы задач:
- ![Задача решена](/img/status_passed_all_tests.svg) - задача решена и прошла все внутренние тесты платформы
- ![Задача решена частично](img/status_tests_passed_partially.svg) - задача решена, но не все тесты платформы пройдены

###  Сейчас здесь есть такие задачи:
1. [Небольшое число Фибоначчи](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%BD%D0%B5%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5-%D1%87%D0%B8%D1%81%D0%BB%D0%BE-%D1%84%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
   файл: fibonachi.py
2. [Последняя цифра большого числа Фибоначчи](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D1%8F%D1%8F-%D1%86%D0%B8%D1%84%D1%80%D0%B0-%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B3%D0%BE-%D1%87%D0%B8%D1%81%D0%BB%D0%B0-%D1%84%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
   файл: fibonachi_last_num.py
3. [Огромное число Фибоначчи по модулю](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%BE%D0%B3%D1%80%D0%BE%D0%BC%D0%BD%D0%BE%D0%B5-%D1%87%D0%B8%D1%81%D0%BB%D0%BE-%D1%84%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8-%D0%BF%D0%BE-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8E)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
   файл: fibonachi_last_num.py
4. [Наибольший общий делитель](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%BD%D0%B0%D0%B8%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B8%D0%B9-%D0%BE%D0%B1%D1%89%D0%B8%D0%B9-%D0%B4%D0%B5%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
   файл: greatest_common_factor.py
5. [Кодирование Хаффмана](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%85%D0%B0%D1%84%D1%84%D0%BC%D0%B0%D0%BD%D0%B0)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
   файл: huffman_coding.py
6. [Декодирование Хаффмана](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%B4%D0%B5%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%85%D0%B0%D1%84%D1%84%D0%BC%D0%B0%D0%BD%D0%B0)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
   файл: huffman_decoding.py
7. [Очередь с приоритетами](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C-%D1%81-%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%B0%D0%BC%D0%B8)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
   файл: binary_max_tree.py
8. [Двоичный поиск](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
   файл: binary_search.py
9. [Число инверсий](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D1%87%D0%B8%D1%81%D0%BB%D0%BE-%D0%B8%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B9)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
   файл: number_of_inversions.py
10. [Точки и отрезки](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D1%82%D0%BE%D1%87%D0%BA%D0%B8-%D0%B8-%D0%BE%D1%82%D1%80%D0%B5%D0%B7%D0%BA%D0%B8)  
    ![Задача решена частично](img/status_tests_passed_partially.svg)  
    файл: quick_sort-Points_and_Segments.py
11. [Сортировка подсчетом](https://github.com/AnastasiaP261/stepik_alghoritms_1#c%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D0%BF%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82%D0%BE%D0%BC)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
    файл: count_sort.py
12. [Наибольшая последовательнократная подпоследовательность](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%BD%D0%B0%D0%B8%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B0%D1%8F-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%BA%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
    файл: largest_subsequence_1.py
13. [Наибольшая невозрастающая подпоследовательность](https://github.com/AnastasiaP261/stepik_alghoritms_1#%D0%BD%D0%B0%D0%B8%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B0%D1%8F-%D0%BD%D0%B5%D0%B2%D0%BE%D0%B7%D1%80%D0%B0%D1%81%D1%82%D0%B0%D1%8E%D1%89%D0%B0%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C)  
    ![Задача решена](/img/status_passed_all_tests.svg)  
    файл: largest_subsequence_2.py
    


## Небольшое число Фибоначчи
Постановка задачи:
> Дано целое число *1 ≤ n ≤ 40*, необходимо вычислить *n*-е число Фибоначчи (напомним, что 
> *F_0=0*, *F_1=1* и *F_n = F_{n-1} + F_{n-2}* при *n ≥ 2*).

Здесь все просто. Представив себе дерево, которое мы могли бы получить, используя наивный рекурсивный алгоритм, замечаем, что одно и то же значение мы вычисляем по несколько раз. Используем это.  
Переделываем рекурсивный алгоритм в итеративный и запоминаем уже вычисленные значения в массиве, из  которого мы можем достать их по мере необходимости.

Код:
``` python
def fib(n):
    fib_list = []
    fib_list.append(0)
    fib_list.append(1)
    if n > 1:
        i = 2
        while i <= n:
            fib_list.append(fib_list[i-1] + fib_list[i-2])
            i += 1
    return fib_list[n]


def main():
    n = int(input())
    print(fib(n))
```

## Последняя цифра большого числа Фибоначчи
Постановка задачи:
>Дано число *1 ≤ n ≤ 10^7*, необходимо найти последнюю цифру *n*-го числа Фибоначчи.  
>Как мы помним, числа Фибоначчи растут очень быстро, поэтому при их вычислении нужно быть 
> аккуратным с переполнением. В данной задаче, впрочем, этой проблемы можно избежать, поскольку 
> нас интересует только последняя цифра числа Фибоначчи: если *0 ≤ a*, *b ≤ 9* — последние цифры 
> чисел *F_i* и *F_{i+1}* соответственно, то *(a+b) mod 10* — последняя цифра числа *F_{i+2}*

Код:
``` python
def fib_digit(n):
    list = []
    list.append(0)
    list.append(1)
    if n > 1:
        i = 2
        while i <= n:
            num = str(list[i - 1] + list[i - 2])
            list.append(int(num[-1]))
            i += 1
    return list[n]


def main():
    n = int(input())
    print(fib_digit(n))

```

## Огромное число Фибоначчи по модулю
Отмечена в курсе как задача повышенной сложности.
Постановка задачи:
>Даны целые числа *1 ≤ n ≤ 10^18* и *2 ≤ m ≤ 10^5*, необходимо найти остаток от деления *n*-го числа 
> Фибоначчи на *m*.

Для решения этой задачи пришлось ознакомиться с [периодом Пизано](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B8%D0%BE%D0%B4_%D0%9F%D0%B8%D0%B7%D0%B0%D0%BD%D0%BE). Например, по модулю 4 последовательность Фибоначчи выглядит как: *0, 1, 1, 2, 3, 1, 0, 1, 1, 2, 3, 1, 0, 1, 1 ...* то есть *период(4) = 6*. Для решения задачи необходимо найти период деления по модулю на наше число.

Код:
``` python
def fib_mod(n, m):
    period = []
    period.append(0)
    period.append(1)

    i = 2
    while i <= n:
        num = period[i - 1] + period[i - 2]
        period.append(num % m)
        if period[i] == period[1] and period[i-1] == period[0]:
            num_period = len(period) - 2
            return period[n % num_period]
        i += 1
    return period[n]


def main():
    n, m = map(int, input().split())
    print(fib_mod(n, m))
```

## Наибольший общий делитель
Постановка задачи:
>По данным двум числам *1 ≤ a*, *b ≤ 2 ⋅ 10^9* найдите их наибольший общий делитель.

Для решения используем алгоритм Евклида.

Код:
``` python
def gcd(a, b):
    if a == 0:
        return b
    if b == 0:
        return a
    if a >= b:
        return gcd(a % b, b)
    if b >= a:
        return gcd(a, b % a)


def main():
    a, b = map(int, input().split())
    print(gcd(a, b))
```

## Кодирование Хаффмана
Постановка задачи:
>По данной непустой строке *s* длины не более *10^4*, состоящей из строчных букв латинского алфавита, 
>постройте оптимальный беспрефиксный код. В первой строке выведите количество различных букв *k*, 
> встречающихся в строке, и размер получившейся закодированной строки. В следующих kk строках запишите 
> коды букв в формате *"letter: code"*. В последней строке выведите закодированную строку.

Данная задача, как мне кажется, уже на порядок "серьезнее" и сложнее предыдущих. Очередь с приоритетами будем реализовывать на базе кучи, которую реализуем на базе класса Дерево(class Tree).

Начнем с того, что считаем все введенные символы в массив, при этом считая их частоты. Далее перекидываем все что получили в очередь с приоритетом, где приоритетом является частота.

Дальше создаем наше дерево на основе данного класса:
``` python
class Tree:
    def __init__(self, val, freq, left=None, right=None):
        self.left = left
        self.right = right
        self.freq = freq    # частота
        self.val = val      # символ
```
Класс имеет единственный метод - констуктор, в котором заданы поля:
- left и right - адреса левого и правого дочернего узла соответственно. Если этот узел - лист, то эти поля равны None
- freq - частота появления данного символа
- val - значение самого символа. Если это простой узел, а не лист, то это значение равно None.

По значениям left, right и val мы можем определить, является ли данный узел листом или нет.

Алгоритм построения дерева такой: достаем из очереди по 2 минимальных элемента(с минимальной частотой) и соединяем их узлом. Полю freq этого узла присваиваем значение сумм частот двух извлеченных элементов и добавляем этот узел в очередь. Таким образом мы построим дерево снизу вверх и самые редко-встречающиеся символы у нас будут лежать на самых глубоких уровнях дерева.

Когда мы закончили построение дерева, мы начинаем создавать коды с помощью функции creating_code. Для этого используем стек -  внем хранятся "незакрытые" вершины(те, через которые мы спустились, но еще не посетили обоих ее детей). При спуске, если идем влево добавляем в нашу кодирующую строку 0, вправо - 1. Если мы оказались в листе - то записываем полученную строку в словарь, где ключом является сам символ. Далее берем следующую вершину из стека, т.е. поднимаемся вверх, при этом каждый раз затирая последний символ строки.

Общий код программы:
``` python
from heapq import heappush as insert, heappop as extract_min
from collections import deque


class Tree:
    def __init__(self, val, freq, left=None, right=None):
        self.left = left
        self.right = right
        self.freq = freq    # частота
        self.val = val      # символ


def creating_code(_dict, root):
    visited = set()
    stack = deque([root])
    string = ''

    while stack:
        vertex = stack[-1]
        if type(vertex.val) is not str:
            if vertex.right in visited:
                visited.add(vertex)
                stack.pop()
                string = string[:-1]
            elif vertex.left in visited:
                stack.append(vertex.right)
                string += '1'
            else:
                stack.append(vertex.left)
                string += '0'
        else:
            _dict[vertex.val] = string
            visited.add(vertex)
            stack.pop()
            string = string[:-1]


def main():
    string = input()
    dictionary = {}

    # считываем символы и их частоты
    for ch in string:
        if ch in dictionary.keys():
            dictionary[ch] += 1
        else:
            dictionary[ch] = 1

    # добавляем символы в очередь, используя частоту в качестве приоритета
    pq = []
    ident = 0
    for ch in dictionary:
        priority = dictionary.get(ch)
        insert(pq, (priority, ident, ch))
        ident += 1
        dictionary[ch] = ''

    if len(pq) == 1:
        dictionary[pq[0][2]] = '0'
    else:
        # создаем узлы дерева
        while len(pq) > 1:
            min1 = extract_min(pq)
            min2 = extract_min(pq)

            if type(min1[2]) is str:
                leaf1 = Tree(min1[2], min1[0])
            else:
                leaf1 = min1[2]
            if type(min2[2]) is str:
                leaf2 = Tree(min2[2], min2[0])
            else:
                leaf2 = min2[2]

            F = Tree(None, leaf1.freq + leaf2.freq, right=leaf2, left=leaf1)
            insert(pq, (F.freq, ident, F))

            ident += 1

        F.freq = None
        creating_code(dictionary, F)

    encoded_string = ''
    for ch in string:
        encoded_string += dictionary[ch]

    print(f'{len(dictionary)} {len(encoded_string)}')
    for i in dictionary:
        print(f'{i}: {dictionary[i]}')
    print(encoded_string)

```

## Декодирование Хаффмана
Постановка задачи:
>Восстановите строку по её коду и беспрефиксному коду символов.  
>В первой строке входного файла заданы два целых числа *k* и *l* через пробел — количество 
> различных букв, встречающихся в строке, и размер получившейся закодированной строки, соответственно. 
> В следующих *k* строках записаны коды букв в формате *"letter: code"*. Ни один код не является 
> префиксом другого. Буквы могут быть перечислены в любом порядке. В качестве букв могут встречаться 
> лишь строчные буквы латинского алфавита; каждая из этих букв встречается в строке хотя бы один раз. 
> Наконец, в последней строке записана закодированная строка. Исходная строка и коды всех букв непусты. 
> Заданный код таков, что закодированная строка имеет минимальный возможный размер.
>В первой строке выходного файла выведите строку _s_. Она должна состоять из строчных букв латинского 
> алфавита. Гарантируется, что длина правильного ответа не превосходит *10^4* символов.

Эта задача решается на основе тех же принципов, что и предыдущая, поэтому опишу кратко. 

Наши символы и их коды передаем в очередь в следующем формате: первым элементом идет массив, состоящий из отдельных символов кода, вторым элементом символ. Так как сравнение в очереди лексикографическое, а все наши коды разные, то конфликтов при сравнении мы не получим, а все наши элементы будут отсортированы так, как если бы мы читали листья дерева слева-направо и снизу-вверх.

Далее, в функции decoding я допустила небольшую глупость и, при каждом приходе в лист возвращалась в корень дерева, это увеличивает время выполнения алгоритма и при таком подходе непонятно, для чего мы тогда изначально сортировали входные данные. Правильнее было бы построить алгоритм обхода с использованием стека и запоминанием посещенных вершин, как в прошлой задаче. 

Код:
``` python
from heapq import heappush as insert, heappop as extract_min


class Tree:
    def __init__(self, val=None, left=None, right=None):
        self.left = left
        self.right = right
        self.val = val      # символ


def decoding(encoded_str, root):
    vertex = root
    string = ''

    for ch in encoded_str:
        if ch == '0':
            vertex = vertex.left
        else:
            vertex = vertex.right

        if vertex.val is not None:
            string += vertex.val
            vertex = root
    return string


def create_decode_tree(pq):
    root = Tree()

    while pq:
        line = extract_min(pq)
        char = line[1]
        line = line[0]
        vertex = root
        for binary in line:
            if binary == '0':
                if vertex.left is None:
                    vertex.left = Tree()
                vertex = vertex.left
            else:
                if vertex.right is None:
                    vertex.right = Tree()
                vertex = vertex.right
        vertex.val = char

    return root


def main():
    k, l = map(int, input().split())    # количество различных букв в строке, размер получившейся закодированной строки
    _dict = {}
    for i in range(k):
        _str = input()
        _dict[_str[3:]] = _str[0]
    encoded_string = input()

    pq = []
    for ch in _dict:
        code = [i for i in ch]
        insert(pq, (code, _dict[ch]))

    root = create_decode_tree(pq)
    print(decoding(encoded_string, root))
```

## Очередь с приоритетами
Постановка задачи:
>Первая строка входа содержит число операций _1 ≤ n ≤ 10^5_. Каждая из последующих _n_ строк задают 
> операцию одного из следующих двух типов:
> - **Insert x**, где _0 ≤ x ≤ 10^9_ — целое число;
> - **ExtractMax**.  
> 
> Первая операция добавляет число _x_ в очередь с приоритетами, вторая — извлекает максимальное число 
> и выводит его.

Реализуем двоичную max-кучу на базе массива, в котором родителем элемента под индексом i является элемент (i / 2), округленный вниз, а детьми элементы (2i) и (2i + 1). 

Код:
``` python
from math import floor
from sys import stdin, stdout


class Heap:
    def __init__(self):
        self.heap = []

    def extract_max(self):
        _max = self.heap[0]
        try:
            self.heap[0] = self.heap.pop()
        except IndexError:
            return _max

        code, child = self.checking_conditions(0)
        if code == -2:
            self.sift_down(0, child)

        return _max

    def insert(self, val):
        self.heap.append(val)
        code, parent = self.checking_conditions(len(self.heap) - 1)

        if code == -1:
            self.sift_up(len(self.heap) - 1, parent)

    def sift_up(self, child, parent):
        code = -1
        while code == -1:
            self.heap[child], self.heap[parent] = self.heap[parent], self.heap[child]
            child = int(floor((child - 1) / 2))
            code, parent = self.checking_conditions(child)

    def sift_down(self, parent, child):
        code = -2
        while code == -2:
            self.heap[parent], self.heap[child] = self.heap[child], self.heap[parent]
            parent = child
            code, child = self.checking_conditions(parent)

    def checking_conditions(self, i):
        child = {}
        if i != 0 and self.heap[i] > self.heap[int(floor((i - 1) / 2))]:
            return -1, int(floor((i - 1) / 2))
        if i != 0:
            if (i * 2 + 1) < len(self.heap) and self.heap[i] < self.heap[i * 2 + 1]:
                child[self.heap[i * 2 + 1]] = i * 2 + 1
            if (i * 2 + 2) < len(self.heap) and self.heap[i] < self.heap[i * 2 + 2]:
                child[self.heap[i * 2 + 2]] = i * 2 + 2
        else:
            if 1 < len(self.heap) and self.heap[i] < self.heap[1]:
                child[self.heap[1]] = 1
            if 2 < len(self.heap) and self.heap[i] < self.heap[2]:
                child[self.heap[2]] = 2
        if len(child) > 0:
            return -2, child[max(child)]
        return 0, -1


def main():
    n = int(stdin.readline())
    heap = Heap()

    for i in range(n):
        line = stdin.readline()
        if 'Insert' in line:
            line = line.split()
            num = int(line[1])

            heap.insert(num)
        else:
            if len(heap.heap) > 0:
                stdout.write(str(heap.extract_max()) + '\n')

```

## Двоичный поиск
Постановка задачи:
>В первой строке даны целое число _1 ≤ n ≤ 10^5_ и массив _A[1…n]_ из _n_ различных натуральных чисел, 
> не превышающих _10^9_, в порядке возрастания, во второй — целое число _1≤k≤10^5_ и _k_ натуральных 
> чисел _b_1, ...,b_k_ и _k_ натуральных чисел, не превышающих _10^9_. Для каждого _i_ от _1_ до _k_ 
> необходимо вывести индекс _n1 ≤ j ≤ n_, для которого _A[j]=b_i_, или _-1_, если такого _j_ нет.

Код:
``` python
def bin_search(arr, req_num):
    a = 0
    b = len(arr) - 1
    while a <= b:
        i_mid = int((b + a) / 2)
        if arr[i_mid] == req_num:
            return i_mid + 1
        if req_num < arr[i_mid]:
            b = i_mid - 1
            continue
        else:
            a = i_mid + 1
            continue
    return -1


def main():
    arr = list(map(int, input().split()))                 # длина массива, массив чисел
    n = arr.pop(0)
    required_numbers = list(map(int, input().split()))     # кол-во искомых чисел, массив искомых чисел
    k = required_numbers.pop(0)

    results = [-1] * k
    for i in range(k):
        results[i] = bin_search(arr, required_numbers[i])
    print(" ".join(str(i) for i in results))
```

## Число инверсий
Постановка задачи:
>Первая строка содержит число _1 ≤ n ≤ 10^5_, вторая — массив _A[1…n]_, содержащий натуральные числа, 
> не превосходящие _10^9_. Необходимо посчитать число пар индексов _1 ≤ i < j ≤ n_, для 
> которых _A[i]>A[j]_. (Такая пара элементов называется инверсией массива. Количество инверсий 
> в массиве является в некотором смысле его мерой неупорядоченности: например, в упорядоченном 
> по неубыванию массиве инверсий нет вообще, а в массиве, упорядоченном по убыванию, инверсию образуют 
> каждые два элемента.)

Решение основано на сортировке слиянием. Вариант итеративного алгоритма был отметен как неподходящий, поскольку при подсчете инверсий важно, чтобы части массива не переставлялись относительно друг друга. 

При сравнении двух кусков массива если элемент левого больше, чем элемент правого, значит есть инверсия и к общему счетчику инверсиймы добавляем число равное длине левой части минус индекс текущего элемента левой части, так как массивы у нас отсортированы и если текущий элемент левого массива меньше элемента правого, то и все следом идущие элементы левого массива меньше элемента правого.

Код:
``` python
counter = 0


def merge(part1, part2):
    global counter
    joint_arr = []
    
    i = 0
    j = 0
    while True:
        if part1[i] > part2[j]:
            counter += len(part1) - i
            joint_arr.append(part2[j])
            j += 1
        else:
            joint_arr.append(part1[i])
            i += 1

        if i == len(part1):
            joint_arr += part2[j:]
            break
        if j == len(part2):
            joint_arr += part1[i:]
            break

    return joint_arr


def merge_sort(arr, left, right):
    if left < right and len(arr) > 1:
        m = int((left + right) / 2)
        arr1 = merge_sort(arr[left:m], 0, len(arr[left:m]))
        arr2 = merge_sort(arr[m:right], 0, len(arr[m:right]))
        arr = merge(arr1, arr2)
    return arr


def main():
    global counter
    n = int(input())
    arr = [int(i) for i in input().split()]

    sorted_arr = merge_sort(arr, 0, n)
    print(counter)
```

## Точки и отрезки
Постановка задачи:
>В первой строке задано два целых числа _1 ≤ n ≤ 50000_ и _1 ≤ m ≤ 50000_ — количество 
> отрезков и точек на прямой, соответственно. Следующие _n_ строк содержат по два целых 
> числа *a_i* и _b_i_ _(a_i ≤ b_i)_ — координаты концов отрезков. Последняя строка содержит _m_ 
> целых чисел — координаты точек. Все координаты не превышают _10^8_ по модулю. Точка считается 
> принадлежащей отрезку, если она находится внутри него или на границе. Для каждой точки в порядке 
> появления во вводе выведите, скольким отрезкам она принадлежит.

**Решение валится на 6-ом тесте платформы. При ручном тестировании я не смогла подобрать тест, который решался бы не правильно.**

Решение построено на основе qsort-3 и двоичного поиска.

Входные координаты отрезков мы записываем в 2 массива: массив начал и массив концов, сортируем их. Если с сортировкой координат концов отрезков все более или менее стандартно, то с двоичным поиском чисел пришлось повозиться, так как стандартная реализация бинарного поиска подразумевает, что нам надо либо найти число и вернуть его позицию, либо, если такого числа нет, вернуть код ошибки(например -1). Но нам нужно возвращать какую то позицию всегда, даже если число не было найдено. 

Поэтому я подробнее остановлюсь на данной функции:
``` python
def points_processing(point, segments, compare):
    if compare == 'for_starts':
        if point < segments[0]:
            return 0
        elif point >= segments[-1]:
            return len(segments)
    else:
        if point <= segments[0]:
            return 0
        elif point > segments[-1]:
            return len(segments)

    if compare == 'for_starts':
        code, i = bin_search(point + 1, segments)
        if segments[i] == point:
            i += 1

        while i > 0 and segments[i - 1] == point + 1:
            i -= 1
    else:
        code, i = bin_search(point - 1, segments)

        while i < len(segments) and segments[i] < point:
            i += 1

    return i
```
Решив вручную на листочке достаточное количество раз данную задачу на разных входных данных, можно заметить закономерности:

- число отрезков, на котором лежит точка, равно разности числа точек начал отрезков, **меньше или равных**(обозначим а) этой точке, и числа концов отрезков, **строго больших**(обозначим b) этой точки(под тем, что точка больше начала/конца я подразумеваю, что координаты точки больше координат начала/конца отрезка)

При поиске числа пересечений мы в каждом из массивов координат начал/концов с помощью бинарного поиска ищем координаты поступившей точки. При этом:

- в поиске среди координат начал: число a равно индексу первого вхождения такой координаты, которая больше координаты точки. Или другими словами, индексу последнего вхождения координаты, равного координате нашей точки и плюс 1.
- в поиске среди координат концов: число b равно индексу первого вхождения координаты самой точки, либо, если такой координаты в массиве не нашлось, то индексу первого вхождения следующей по возрастанию найденной координаты.


Код:
``` python
import random


def partition(arr, l, r):
    rand_i = random.randint(l, r - 2)
    arr[l], arr[rand_i] = arr[rand_i], arr[l]
    pivot = arr[l]
    equal_right, less_right = l, l

    for i in range(l + 1, r):
        if arr[i] < pivot:
            less_right += 1
            arr[less_right], arr[i] = arr[i], arr[less_right]
        elif arr[i] == pivot:
            equal_right += 1
            less_right += 1
            arr[equal_right], arr[less_right] = arr[less_right], arr[equal_right]
            if less_right != i:
                arr[equal_right], arr[i] = arr[i], arr[equal_right]

    if less_right != equal_right:
        new_equal_right = less_right
        for i in range(equal_right, l - 1, -1):
            arr[i], arr[less_right] = arr[less_right], arr[i]
            less_right -= 1
        return less_right + 1, new_equal_right + 1
    else:
        return l, equal_right + 1


def quick_sort(arr, l, r):
    if l >= r or r - l == 1:
        return
    lm, rm = partition(arr, l, r)
    quick_sort(arr, l, lm)
    quick_sort(arr, rm, r)


def points_processing(point, segments, compare):
    if compare == 'for_starts':
        if point < segments[0]:
            return 0
        elif point >= segments[-1]:
            return len(segments)
    else:
        if point <= segments[0]:
            return 0
        elif point > segments[-1]:
            return len(segments)

    if compare == 'for_starts':
        code, i = bin_search(point + 1, segments)
        if segments[i] == point:
            i += 1

        while i > 0 and segments[i - 1] == point + 1:
            i -= 1
    else:
        code, i = bin_search(point - 1, segments)

        while i < len(segments) and segments[i] < point:
            i += 1

    return i


def bin_search(point, segments):
    a = 0
    b = len(segments) - 1

    i_mid = -1
    while a <= b:
        i_mid = int((b + a) / 2)
        if segments[i_mid] == point:
            return 0, i_mid
        if point < segments[i_mid]:
            b = i_mid - 1
            continue
        else:
            a = i_mid + 1
            continue

    return -3, i_mid


def main():
    random.seed()
    n, m = map(int, input().split())        # количество отрезков и точек на прямой

    segments_starts = [-1] * n
    segments_ends = [-1] * n
    for i in range(n):
        start, end = map(int, input().split())
        segments_starts[i] = start
        segments_ends[i] = end

    quick_sort(segments_starts, 0, n)
    quick_sort(segments_ends, 0, n)
    
    for i in input().split():
        point = int(i)
        print(points_processing(point, segments_starts, compare='for_starts') -
              points_processing(point, segments_ends, compare='for_ends'), end=' ')

```

## Cортировка подсчётом 
Постановка задачи:
>Первая строка содержит число _1 ≤ n ≤ 10^4_, вторая — _n_ натуральных чисел, не превышающих 10.
> Выведите упорядоченную по неубыванию последовательность этих чисел.

Сначала пройдем по полученному массиву и подсчитаем, сколько каждой цифры мы встретили. Затем из массива подсчета восстановим новый массив, в котором числа будут уже упорядочены.

Код:
``` python
from sys import stdout, stdin


def main():
    n = int(stdin.readline())
    nums = [int(i) for i in stdin.readline().split()]
    counting_val = [0] * 10

    for i in range(n):
        counting_val[nums[i] - 1] += 1

    for i in range(1, 10):
        counting_val[i] += counting_val[i - 1]

    sorted_values = [0] * n
    for i in range(n - 1, -1, -1):
        sorted_values[counting_val[nums[i] - 1] - 1] = nums[i]
        counting_val[nums[i] - 1] -= 1

    stdout.write(' '.join([str(i) for i in sorted_values]))
```

## Наибольшая последовательнократная подпоследовательность
Постановка задачи:
>Дано целое число 
> <a href="https://www.codecogs.com/eqnedit.php?latex=\inline&space;1\leq&space;n\leq&space;10^3" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\inline&space;1\leq&space;n\leq&space;10^3" title="1\leq n\leq 10^3" /></a>
> и массив _A[1…n]_ натуральных чисел, не превосходящих 
> <a href="https://www.codecogs.com/eqnedit.php?latex=\inline&space;2*10^9" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\inline&space;2*10^9" title="2*10^9" /></a>
> . Выведите максимальное _1 ≤ k ≤ n_, для которого найдётся подпоследовательность 
> <a href="https://www.codecogs.com/eqnedit.php?latex=\inline&space;1&space;\leq&space;i_1&space;<&space;i_2&space;<&space;...&space;<&space;i_k&space;\leq&space;n" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\inline&space;1&space;\leq&space;i_1&space;<&space;i_2&space;<&space;...&space;<&space;i_k&space;\leq&space;n" title="1 \leq i_1 < i_2 < ... < i_k \leq n" /></a>
> длины _k_, в которой каждый элемент делится на предыдущий (формально: для  всех 
> <a href="https://www.codecogs.com/eqnedit.php?latex=\inline&space;1&space;\leq&space;j&space;<&space;k,&space;A[i_j]&space;\mid&space;A[{i_{j&plus;1}}]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\inline&space;1&space;\leq&space;j&space;<&space;k,&space;A[i_j]&space;\mid&space;A[{i_{j&plus;1}}]" title="1 \leq j < k, A[i_j] \mid A[{i_{j+1}}]" /></a>
> ).

За квадратичное время проходим по массиву и ищем пары (i; j), где _1 ≤ j < i ≤ n_. После прохода у нас
будет массив чисел, каждый элемент которого - это счетчик цепочек, заканчивающихся в A[i].

Код:
``` python
def search_ls(arr):
    ls = [0] * len(arr)

    for i in range(len(arr)):
        ls[i] = 1
        for j in range(i):
            if arr[i] % arr[j] == 0 and ls[j] + 1 > ls[i]:
                ls[i] = ls[j] + 1
    return max(ls)


def main():
    n = int(input())
    consist = [int(i) for i in input().split()]

    print(search_ls(consist))
```

## Наибольшая невозрастающая подпоследовательность
Постановка задачи:
> Дано целое число 
> <a href="https://www.codecogs.com/eqnedit.php?latex=1&space;\leq&space;n&space;\leq&space;10^5" target="_blank"><img src="https://latex.codecogs.com/gif.latex?1&space;\leq&space;n&space;\leq&space;10^5" title="1 \leq n \leq 10^5" /></a>
> и массив _A[1…n]_, содержащий неотрицательные целые числа, не превосходящие 
> <a href="https://www.codecogs.com/eqnedit.php?latex=10^9" target="_blank"><img src="https://latex.codecogs.com/gif.latex?10^9" title="10^9" /></a>
> . Найдите наибольшую невозрастающую подпоследовательность в _A_. В первой строке выведите её длину _k_, 
> во второй — её индексы 
> <a href="https://www.codecogs.com/eqnedit.php?latex=i&space;\leq&space;i_1&space;<&space;i_2&space;<&space;...&space;<&space;i_k&space;\leq&space;n" target="_blank"><img src="https://latex.codecogs.com/gif.latex?i&space;\leq&space;i_1&space;<&space;i_2&space;<&space;...&space;<&space;i_k&space;\leq&space;n" title="i \leq i_1 < i_2 < ... < i_k \leq n" /></a>
> (таким образом,
> <a href="https://www.codecogs.com/eqnedit.php?latex=A[i_1]&space;\geq&space;A[i_2]&space;\geq&space;...&space;\geq&space;A[i_n]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?A[i_1]&space;\geq&space;A[i_2]&space;\geq&space;...&space;\geq&space;A[i_n]" title="A[i_1] \geq A[i_2] \geq ... \geq A[i_n]" /></a>
> ).

Поскольку в данной задаче объем входных данных уже можно считать достаточно большим, мы не можем 
воспользоваться алгоритмом, работающим за квадратичное время. Поэтому воспользуемся другим алгоритмом, работающим за 
время _n log(n)_.  
В этом алгоритме мы используем 3 массива: d, pos и prev (пояснения к ним в тексте программы). Линейно проходим по последовательности,
заполняя эти массивы. После прохода в массив subseq_ind запишем нашу цепочку подпоследовательности.
Первый элемент мы достаем из массива pos, его индекс всегда равен длине найденной максимальной последовательности. 
Далее в цикле проходимся по массиву prev и все остальные элементы достаем из него.


Код:
``` python
from sys import stdin
from bisect import bisect_right


def search_ls(a):
    n = len(a)
    # храним числа, на которые окачивается ВП длины i (или наименьшее из них)
    # +2 для того, чтобы нулевой элемент всегда был -бесконечностью, а n бесконечностью
    d = [10**9 + 1] * (n + 2)
    d[0] *= -1
    pos = [''] * (n + 1)                    # индексы эл-тов, на которые заканчивается ВП длины i
    prev = [''] * n                         # позиция предыдущего элемента для a[i]
    length = 0                              # длина наибольшей последовательности

    for i in range(n):
        j = bisect_right(d, a[i])
        if d[j - 1] <= a[i] < d[j]:
            d[j] = a[i]
            pos[j] = i
            prev[i] = pos[j - 1]
            length = max(length, j)

    subseq_ind = []
    p = pos[length]
    while type(p) is int:
        subseq_ind.append(p)
        p = prev[p]
    return length, subseq_ind


def main():
    n = int(stdin.readline())
    consist = [int(i) for i in stdin.readline().split()]

    if n > 1:
        # так как модуль bisect работает только с возрастающими последовательностями, сделаем реверс полученного массива
        length, subsequence = search_ls(list(reversed(consist)))
        print(length)
        print(' '.join([str(n - x) for x in subsequence]))
        # не отнимаем дополнительную единицу так как индексация начинается с 1
    else:
        print(1)
        print(1)
```

<!---
## Название
Постановка задачи:
>

Текст

Код:
``` python

```
-->